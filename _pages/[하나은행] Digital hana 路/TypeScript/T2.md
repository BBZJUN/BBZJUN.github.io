---
title: "TypeScript"
tags:
    - 타입스크립트
date: "2024-09-10"
thumbnail: "/assets/img/thumbnail/ts.jpg"
bookmark: true
---

# 타입스크립트
---


## 함수타입


```typescript
// Call Signature: (a:number, b:number) => number
function add(a : number, b: number) {
   return a + b;
}

add(1);
//Error : Expected 2 arguments, but got 1.
add(1, 2); // Ok
add(1, 2, 3);
//Error : Expected 2 arguments, but got 3.
```
* 타입스크립트는 함수에 선언된 모든 매개변수가 필수라고 가정한다!

---

```typescript
const introduce = (name:string, 
height?:number) => { //?는 옵셔널파라미터 있어도되고 없어도 되고
   console.log(`이름 : ${name}`);
   console.log(`키 : ${height + 10}`)
//Error : 'height' is possibly 'undefined'.
}

introduce("김현준"); // OK
introduce("김현준", undefined); // OK
introduce("김현준", 170); // OK
```
* 함수 호출에 선택적 매개변수를 인수로 제공할 필요 X 
선택적 매개변수에는 항상 | undefined 가 
유니언타입으로 추가 되어있기 때문!
* 선택적 매개변수는 끝에 위치해야함
---

```typescript
const introduce2 = (name:string, 
height : number|undefined ) => {
   console.log(`이름 : ${name}`);
if(typeof height === 'number'){
   	console.log(`키 : ${height + 10}`)   
 	}
}

introduce2("김현준"); // Error : Expected 2 arguments, but got 1.
introduce2("김현준", undefined); // OK
introduce2("김현준", 170); // OK

```
* 선택적 매개변수는 | undefined를 포함하는 유니언 타입 매개변수와 다름.
?으로 표시된 선택적 매개변수가 아닌 매개변수는 
값이 명시적으로 undefined 일지라도 항상 제공되어야 한다.

---

```javascript
const getSum = (...rest: number[]) =>{
//rest로 여러개의 넘버를 받음(넘버만!)

const getSum2 = (a: number,...rest:[number, number]) =>{
//튜플로 rest로 두개의 넘버를 받음

```

```javascript
function singSongRecursive(songs : string[], count = 0) : number {
    return songs.length ? singSongRecursive(songs.slice(1), count + 1) : count;
}
// 재귀함수에서의 명시적 반환 타입지정
```

```javascript
let singer : (song : string) => string;

singer = function(song) {
    // song : string의 타입
    return `Singing : ${song.toUpperCase()}!`; // OK
}
//타입 스크립트는 선언된 타입의 위치에 제공된 함수의 매개변수 타입을 유추할 수 있다!
```

### void 반환타입

```javascript
function logSong(song : string) : void {
  if(!song){
    return; // OK!  return undefined; 도 OK!
  }
  console.log(`${song}`);

  return true;   // Error! - Type 'boolean' is not assignable to type 'void'.
}
//  ← void를 반환하도록 선언되었으므로 값 반환을 허용하지 않음.

// But, 다음과 같이 화살표 함수는 구문 오류 없음!


type VoidReturn = () => void;
const test2:VoidReturn = () => 11;  // OK!
test2().toString(); // ?
//일부 함수는 어떤 값도 반환하지 않을 수 있음 -> 타입스크립트는 void 키워드를 사용해 반환값이 없는 함수의 타입을 확인할 수 있음
//void는 그냥 반환을 하려해도 타입스크립트는 검사를 안한다

//fuction은 등록을 해야해서 void를 썻는데 return이 있으면 오류뜨고
//화살표함수는 이미 등록이라서 void인데 return이 있어도 ㅇㅋ
```

### never 반환타입


never 반환 함수는 (의도적으로) 항상 오류를 발생시키거나 무한 루프를 실행하는 함수
```javascript
function fail(message : string) : never {
    throw new Error(`Invariant Failure : ${message}`);
    // JS는 return undefined; 가 생략
}

function workWithUnsafeParam(param : unknown){
    if(typeof param !== "string"){
        fail(`param should be a string, not ${typeof param}`);
    }

    // 여기에서 param의 타입은 string으로 알려짐
    param.toUpperCase();
}

```


### 함수 오버로드


동일한 이름에 매개 변수만 다른 여러 버전의 함수를 만드는 것
매개변수의 형태가 다양한 여러 케이스에 대응하는 같은 이름을 가진 함수를 만드는 것

```javascript
// 서로 다른 버전의 함수들(선언부) -> `오버로드 시그니처`
function func(a : number): void;
function func(a : number, b : number, c : number) : void;

// 실제 구현부 -> `구현 시그니처`
function func(a:number, b?: number, c?:number) {
  if(typeof b === 'number' && typeof c === 'number') {
    console.log(a + b + c);
  } else {
    console.log(a * 20);
  }
}

func(1);
func(1,2,3);

```


### this


동일한 이름에 매개 변수만 다른 여러 버전의 함수를 만드는 것
매개변수의 형태가 다양한 여러 케이스에 대응하는 같은 이름을 가진 함수를 만드는 것

```javascript
function f(cb: (this: void) => number) {
    return cb();
}
// 이 함수 f는 콜백 함수 cb를 매개변수로 받고 있는데, cb는 this를 사용하지 않는 함수여야 한다는 것을 명시하고 있습니다. 이를 위해 cb의 타입으로 (this: void) => number를 지정했는데, 이는 this가 void 타입임을 나타냅니다. 즉, this를 사용하지 않는 함수여야 한다는 뜻입니다.

const obj = { id: 1 };

function x(this: typeof obj) {
    return this.id;
}

function y() {
    return 1;
}

f(x); // Fail
f(y); // OK


// f(x):
// 실패하는 이유는 x 함수가 this로 obj를 필요로 하지만, f 함수는 cb의 this가 void라고 명시했기 때문입니다. 즉, f는 this를 사용하지 않는 함수만 받을 수 있는데, x는 this를 사용하므로 타입 호환이 되지 않습니다.
// 오류 메시지에서 설명하듯이, void 타입의 this는 { id: number }와 호환되지 않습니다.

// f(y):
// 성공하는 이유는 y 함수는 this를 사용하지 않으므로, this: void로 선언된 콜백 함수로 사용할 수 있기 때문입니다.
```